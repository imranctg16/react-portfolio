# Mysql Gone Away

# MySQL "Server Has Gone Away" Investigation & Fix

## The Problem That Drove Me Crazy

We were getting random `SQLSTATE[HY000]: General error: 2006 MySQL server has gone away` errors in production. Not consistently - just randomly enough to make debugging a nightmare.

**Error Pattern:**

- Happened during ticket service operations
- Only occurred sometimes (maybe 1 in 50 requests)
- No obvious pattern or trigger
- Stack traces pointed to database operations inside transactions

**Production Error Example:**

```
SQLSTATE[HY000]: General error: 2006 MySQL server has gone away (SQL: select * from `tickets` where `tickets`.`id` = 189713 limit 1)

#0 /var/www/html/app/Services/TransitionService.php(856): updateTicket()
#1 /var/www/html/app/Services/TransitionFieldValueService.php(914): storeWithRepeater()

```

## Architecture Overview

```
┌─────────────────────┐                    ┌──────────────────────┐
│  Notification       │    API Calls       │  Ticket Service      │
│  Service            │ ──────────────────> │                      │
│                     │                    │  • Transitions       │
│  • Scheduled Jobs   │                    │  • DB Transactions   │
│  • Kill Process ⚠️   │                    │  • Business Logic    │
└─────────────────────┘                    └──────────────────────┘
          │                                           │
          │                                           │
          └───────────── Shared MySQL Server ────────┘
                         common-mysql
                    ┌─────────────────────┐
                    │ • notification_db   │
                    │ • ticket_service_db │
                    └─────────────────────┘

```

## The Root Cause Discovery

### The Smoking Gun

Found this in our notification service (scheduled every minute):

```php
// NotificationService.php - The Culprit!
public function killSleepProcess($type = null)
{
    $results = DB::connection('mysql')->select(DB::raw("SHOW processlist"));
    foreach ($results as $result) {
        if ($result->Command == "Sleep") {
            DB::connection('mysql')->select(DB::raw("KILL $result->Id"));
        }
    }
}

```

**What this was doing:**

- Running every 60 seconds via cron
- Killing ALL sleeping connections on the MySQL server
- Not just notification service connections - EVERYTHING
- Including active ticket service operations that briefly went idle

### The Sequence

```
1. Notification Job Dispatched
   ├─> API call to Ticket Service

2. Ticket Service Processing
   ├─> DB::beginTransaction()
   ├─> Complex business logic
   ├─> Connection goes "idle" for 30 seconds (normal)

3. Kill Process Execution (runs every minute)
   ├─> Sees "Sleep" connection from Ticket Service
   ├─> KILL [connection_id]
   ├─> Connection murdered mid-transaction

4. Ticket Service Resumes
   ├─> Tries to execute SQL query
   ├─> Connection is dead
   ├─> ❌ "MySQL server has gone away"
   ├─> ❌ Cannot auto-reconnect (inside transaction)
   ├─> ❌ Transaction fails and rolls back

```

### Auto Reconnect Failure

```php
// This works - Laravel auto-reconnects
DB::select('SELECT * FROM tickets WHERE id = 123');

// This fails - no auto-reconnect inside transactions
DB::beginTransaction();
sleep(60); // Connection gets killed here
DB::select('SELECT * FROM tickets WHERE id = 123'); // ❌ MySQL gone away
DB::commit(); // ❌ This fails too

```

**Reason:** Laravel prevents auto-reconnection during transactions to maintain data integrity and prevent partial transaction states.

## Reproducing the Issue

### Test Case Setup

I created a reproduction job to prove the theory:

```php
<?php
// GoneAwayReproJob.php
class GoneAwayReproJob implements ShouldQueue
{
    public int $timeout = 300; // Prevent worker timeout

    public function handle(): void
    {
        try {
            // Start transaction to prevent auto-reconnection
            DB::beginTransaction();

            // Get our connection ID
            $connId = DB::select('SELECT CONNECTION_ID() as id')[0]->id;
            Log::warning('[REPRO] Connection ID: ' . $connId);

            // Sleep long enough for kill process to find us
            sleep(90);
            Log::warning('[REPRO] Woke up from sleep, testing connection...');

            // This should fail if connection was killed
            $result = DB::select('SELECT 1 as test');

            DB::commit();
            Log::warning('[REPRO] Success - no connection issues!');

        } catch (\\Throwable $e) {
            Log::error('[REPRO] Got the expected error: ' . $e->getMessage());
            throw $e;
        }
    }
}

```

### Test Results

**Before Fix:**

```
[REPRO] Connection ID: 1234
[REPRO] Woke up from sleep, testing connection...
[ERROR] Got the expected error: SQLSTATE[HY000]: General error: 2006 MySQL server has gone away

```

**After Fix:**

```
[REPRO] Connection ID: 1234
[REPRO] Woke up from sleep, testing connection...
[REPRO] Success - no connection issues!

```

## The Solution

### Smart Kill Process Implementation

Instead of killing ALL sleeping connections, implemented intelligent filtering:

```php
<?php
// Fixed NotificationService.php
public function killSleepProcess($type = null, $limit = null)
{
    $results = DB::connection('mysql')->select(DB::raw("SHOW processlist"));
    if (!empty($type)) {
        return $this->sendResponse($results, 'All processlist');
    }

    $killedCount = 0;
    $minimumSleepTime = $limit ? (int)$limit * 60 : 300; // Default 5 minutes

    foreach ($results as $result) {
        if ($result->Command == "Sleep") {
            // Skip connections not sleeping long enough
            if ($result->Time < $minimumSleepTime) {
                Log::info('[KILL_PROCESS] Skipping connection - not sleeping long enough', [
                    'connection_id' => $result->Id,
                    'database' => $result->db,
                    'sleep_time' => $result->Time,
                    'minimum_required' => $minimumSleepTime
                ]);
                continue;
            }

            // Kill truly idle connections
            try {
                DB::connection('mysql')->select(DB::raw("KILL $result->Id"));
                $killedCount++;
                Log::warning('[KILL_PROCESS] Killed long-sleeping connection', [
                    'connection_id' => $result->Id,
                    'database' => $result->db,
                    'sleep_time' => $result->Time
                ]);
            } catch (\\Exception $e) {
                Log::error('[KILL_PROCESS] Failed to kill connection', [
                    'connection_id' => $result->Id,
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    return $this->sendResponse(
        ['killed_count' => $killedCount],
        "Killed $killedCount connections sleeping > " . ($minimumSleepTime/60) . " minutes"
    );
}

```

### Configurable Command

Updated the Artisan command to accept parameters:

```php
<?php
// KillSleepProcess.php
class KillSleepProcess extends Command
{
    protected $signature = 'kill:sleep_process {--limit= : Minimum sleep time in minutes before killing connections (default: 5)}';

    public function handle()
    {
        $limit = $this->option('limit');
        $response = $this->killProcess->killSleepProcess(null, $limit);

        $this->info("Kill process completed: " . $response->getData()->message);
        return 0;
    }
}

```

### Usage Examples

```bash
# Use default 5-minute threshold
php artisan kill:sleep_process
# Output: Kill process completed: Killed 0 connections sleeping > 5 minutes

# Use custom 15-minute threshold
php artisan kill:sleep_process --limit=15
# Output: Kill process completed: Killed 2 connections sleeping > 15 minutes

# Use 30-minute threshold for conservative cleanup
php artisan kill:sleep_process --limit=30

```

### Key Changes

1. **Minimum Sleep Time Check**: Only kill connections sleeping > threshold
2. **Configurable Thresholds**: Command accepts `-limit` parameter
3. **Comprehensive Logging**: All actions logged with context
4. **Error Handling**: Graceful handling of kill failures
5. **Metrics**: Returns count of killed connections

### Before vs After Behavior

**Before (Aggressive):**

```
SHOW PROCESSLIST:
ID | User | Command | Time | Info
1  | root | Sleep   | 5    | NULL  ← KILLED
2  | root | Sleep   | 30   | NULL  ← KILLED
3  | root | Sleep   | 300  | NULL  ← KILLED
4  | root | Sleep   | 900  | NULL  ← KILLED

Result: All sleeping connections killed

```

**After (Smart):**

```
SHOW PROCESSLIST:
ID | User | Command | Time | Info
1  | root | Sleep   | 5    | NULL  ← SKIPPED (< 5 min)
2  | root | Sleep   | 30   | NULL  ← SKIPPED (< 5 min)
3  | root | Sleep   | 300  | NULL  ← SKIPPED (= 5 min)
4  | root | Sleep   | 900  | NULL  ← KILLED (> 5 min)

Result: Only truly idle connections killed

```

## Future Improvements

1. **Connection Pooling**: Implement proper database connection pooling
2. **Circuit Breakers**: Add circuit breaker pattern for inter-service calls
3. **Health Checks**: Regular MySQL connection health validation
4. **Metrics Dashboard**: Grafana dashboard for connection monitoring

---

**TL;DR**: A scheduled cleanup process was killing active database connections from other services, causing "MySQL server has gone away" errors during transactions. Fixed by implementing smart filtering that only kills truly idle connections (5+ minutes) instead of all sleeping connections.

**Status**: ✅ **FIXED** - Zero MySQL connection errors since deployment